Проект зроблений Криворучко Тимофієм, ІПЗ-2.01 по цим відео:

https://www.youtube.com/watch?v=H-RCv-bbfa8
https://www.youtube.com/watch?v=2fcO9RUOGg4

Raymarching - це досить нова техніка, яка використовується для рендерингу сцен реального часу. Вона особливо цікава тим, що повністю обчислюється у шейдері екранного простору. Іншими словами, рендерер не отримує доступу до даних мішів і сцена малюється на одному чотирикутнику, що покриває всю область видимості камери. Об'єкти в сцені задаються аналітичним рівнянням, що описує найкоротшу відстань між точкою та поверхнею всіх об'єктів сцени (тому повністю техніка називається полями відстаней Raymarching-а). Виявляється, що навіть за наявності лише цієї інформації ми можемо створювати напрочуд складні та красиві сцени. Більше того, завдяки тому, що ми не використовуємо полігональні міші (і замість них застосовуються математичні рівняння), тут, на відміну від традиційного рендерера, можна ставити ідеально плавні поверхні.[1]

Для роботи коду вап потрібно завантажити важливі компоненти программи, а саме:

	1.python 3.11 чи вище. Можна завантажити з їх офіційного сайту.
	2.moderlgl. Можна завантажити через командний рядок, ввівши наступну команду:
pip install moderngl
	3.moderngl-window. Можна завантажити через командний рядок, ввівши наступну команду:
pip install moderngl_window

Тепер давайте розглянемо код і розберемо що і як тут працює:

Программа сокладаєтся з 4-х основних файлів:

	*main.py
	*fragment_shader.glsl
	*material.glsl
	*map.glsl

Також э файл hg_sdf.glsl який є бібліотекою для коректної роботи программи. 

Файл main.py. Служить зв'язуючим компонентом всього коду. Запусає программу та через нього підключаются додаткові компоненти в файл fragment_shader.glsl. Спочатку створюєтся новий класс App з методом mglw.WindowConfig. Далі вказуєтся розмір нашого вікна в якому і буде весь процесс та вказуєтся попка з іншими компонентами програми.
Далі іде функція __init__, в якому прописуєтся де саме компоненти программи для продовження роботи коду. Після чого прописуються текстури до програми та іх місцезнаходження. 
Наступне у нас іде функція on_render, яка запускаэ процес рендеру сцени - відображення картинки на екран. 
Після чого іде ще 2 функції - on_mouse_position event та mouse_scroll_event, де перша служить для передачі даних в програму про місцезнаходження курсору на екрані, а друга дає команду на поворот сцени, якщо курсор був переміщений в рамках вікна.
Останні 2 строчки коду, які не входять в класс App, запускають всю програму.

Файл fragment_shader.glsl. Файл в якому і йде вся основна робота.
Спочакту підключаєся версія glsl, а саме версія 430 core, вона і є останньою. Далі підключаемо бібліотеку hg_sdf.glsl та 2 файли map.glsl та material.glsl, про які пізніше. 
Підключаемо написані в файлі main.py додаткові функції та текстури. Далі у нас ідуть константи:

	*FOV - радіус огляду камери
	*MAX_STEPS - кількість ітерацій циклу відображення графіки. Впливає на чіткість відображення графіки. 
	*MAX_DIST - як далеко буде йти проритовка графіки перед тим як стаати пікселем неба.
	*EPSILON - потрібна для прорахунків трафіки

Перед функціями йде ще 2 змінних - cubeSize та cubeScale. Потрібні для коректного відображення текстур на об'єтах.
Перейдемо до функцій:
Функція triPlanar наносить на обьекти текстури і вирівнює їх нормалями.
Функція fDisplace дозваляє рухатися сфері посередині.
Функції fOpUnionID, fOpDiffirenceID та fOpDifferenceColumnsID. Дозваляють вирізати та поєднювати різні обьекти. Також дозволяє робити це фігурно. 
Функція rayMarch це сама графіка. Працює по такому алгоритму:
	1. Пускаємо луч від положення камери
	2. Від положення нашої камери будуємо коло радіусом до найближчого обьєкту.
	3. Від місця перетину луча і дуги кола будуємо це коло, також до найближчого обьекту.
	4. Повторюємо процесс n-ну кількість разів.
Функція getNormal. Робить графіку більш рівною.
Функція getSofthadow. Додає напівтінь
Функція getLight. Додає світло і тінь.
Функція getCam. Виставлєяє камеру.
Функція mouseControl. Додає повороти камерою за допомогою використання миші.
Функція render відповідає за виведення картинки на екран. Збирає в собі всі раніше пояснені функції
Функція main запускає функцію render.

Також в проекті є раніше згадані map.glsl та material.glsl. Перший відповідає за розміщення об'єктів на екрані. Де, що і як буде знаходитись. Які будуть розміри об'ектів та які на них юудуть кольори та текстури. Другий файл відповідає за самі текстури. Там є як і заготовлені текстури, так і текстури які створюются і накладуются у программі.

В проекті ще є файл vertex_shader.glsl, який відповідає за рендер вершин, тобто відповідає за полігони, яких в нашому проекті немає.

Підсумовуючи все раніше сказане, можна сказати, що на виході ми отримуємо 3Д графіку, яка прораховуєтся і відображаєтся в реальному часі. На мою особисту думку, raymarching це повноцінний інструмент для відтворення 3Д графіки, завдяки якому можна досягти нового рівня в цій галузі.

Джерела:
1.https://habr.com/ru/articles/503554/